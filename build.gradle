/*
 * Copyright 2012-2013 Canoo Engineering AG.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.text.SimpleDateFormat

apply from: rootProject.file('gradle/javafx.gradle')

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'net.sourceforge.cobertura:cobertura:2.0.3'
        classpath 'net.saliman:gradle-cobertura-plugin:2.2.4'
        classpath 'org.gradle.api.plugins:gradle-nexus-plugin:0.7.1'
    }
}

Date buildTimeAndDate = new Date()
ext {
    buildDate = new SimpleDateFormat('yyyy-MM-dd').format(buildTimeAndDate)
    buildTime = new SimpleDateFormat('HH:mm:ss.SSSZ').format(buildTimeAndDate)
}

allprojects {
    apply plugin: 'base'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    repositories {
        jcenter()
        flatDir { dirs jfxrtLocation.absolutePath }
    }

    if (JavaVersion.current().isJava8Compatible()) {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}

subprojects { subproj ->
    plugins.withType(GroovyPlugin) {
        subproj.apply from: rootProject.file('gradle/coverage.gradle')

        configurations {
            compileOnly
            testCompileOnly
        }

        subproj.archivesBaseName = "dolphin-${project.name}"

        subproj.tasks.withType(JavaCompile) {
            sourceCompatibility = '1.6'
            targetCompatibility = '1.6'
        }

        dependencies {
            compile "org.codehaus.groovy:groovy-all:$groovyVersion"
            testCompile 'org.spockframework:spock-core:0.7-groovy-2.0', {
                exclude group: 'org.codehaus.groovy', module: 'groovy-all'
            }
        }

        sourceSets {
            main {
                compileClasspath += [configurations.compileOnly]
            }
            test {
                compileClasspath += [configurations.testCompileOnly]
            }
        }

        javadoc {
            classpath += [configurations.compileOnly]
        }

        idea {
            module {
                scopes.PROVIDED.plus += [configurations.compileOnly]
                scopes.PROVIDED.plus += [configurations.testCompileOnly]
            }
        }

        tasks.withType(AbstractCompile) {
            if (rootProject.hasProperty('lint') && rootProject.lint.toBoolean()) {
                options.compilerArgs = [
                    '-Xlint:all', '-Xlint:deprecation', '-Xlint:unchecked'
                ]
            }
        }

        task makeDirs(description: 'make all dirs for project setup') << {
            def sources = [sourceSets.main, sourceSets.test]
            sources*.allSource*.srcDirs.flatten().each { File srcDir ->
                println "making $srcDir"
                srcDir.mkdirs()
            }
        }

        if (subproj.publishJars.toBoolean()) {
            task sourceJar(type: Jar, dependsOn: classes) {
                group 'Build'
                description 'An archive of the source code'
                classifier = 'sources'
                from sourceSets.main.allSource
            }

            javadoc {
                failOnError = false
            }

            task groovydocJar(type: Jar, dependsOn: groovydoc) {
                group 'Build'
                classifier = 'javadoc'
                from groovydoc.destinationDir
            }

            subproj.apply from: rootProject.file('gradle/publishing.gradle')

            artifacts {
                archives jar
                archives sourceJar
                archives groovydocJar
            }

            jar.finalizedBy sourceJar
            jar.finalizedBy groovydocJar
        }
    }
}

def distDir = new File(rootDir, 'dist')
subprojects.each { proj ->
    evaluationDependsOn proj.path
    if (proj.tasks.findByName('jar')) {
        proj.jar.doLast { jarTask ->
            copy {
                from jarTask.archivePath
                into distDir
            }
        }
    }
    proj.tasks.create(name: 'sourceZip', type: Zip) {
        classifier = 'src'
        destinationDir = distDir
        from proj.sourceSets*.allSource
    }
}

apply {
    from 'buildSrc/scripts/docsDependencies.gradle'
    from 'buildSrc/scripts/docs.gradle'
}

task apidoc(group: 'Documentation', type: Groovydoc) {
    def coreProjects = subprojects.findAll { !it.name.contains('demo') }
    source coreProjects.collect { project -> project.sourceSets.main.allSource }
    classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })
    groovyClasspath = classpath
    destinationDir = new File(buildDir, 'api')
    docTitle = "Open Dolphin API documentation"
    footer = "Created ${new java.text.SimpleDateFormat().format(new Date())}"
    header = docTitle
    windowTitle = docTitle
    overview = new File('docs/docOverview.html')
    link("http://download.oracle.com/javase/7/docs/api", "java.", "javax.")
    link("http://docs.oracle.com/javafx/2/api/", "javafx.")
    link("http://groovy.codehaus.org/api", "groovy.", "org.codehaus.groovy.")
}

def demos = new File(rootDir, 'subprojects/demo-javafx/combined/src/main/groovy/org/opendolphin/demo')
    .list()
    .findAll { it.startsWith('start') && it.endsWith('Demo.groovy') }
    .collect { it - 'start' - 'Demo.groovy' }

task listDemos(description: "List all available demos") << {
    demos.sort().each { println "gradlew ${it}Demo" }
}

demos.each { demo ->
    task "${demo}DemoPreparation"(description: "internal") << {
        project(':demo-javafx-combined').ext.set('demoApplicationName', demo)
    }
    def group = demo.startsWith('Grails') ? 'Demo (server required)' : 'Demo'
    task "${demo}Demo"(group: group, dependsOn: ["${demo}DemoPreparation", ':demo-javafx-combined:run'],
        description: "start the ${demo} demo") {}
}

task cleanRootProject(type: Delete) {
    delete 'build'
    delete 'dist'
}

clean.finalizedBy cleanRootProject

task(projectCoverage, description: 'This task merges the module cobertura reports and generates one report.') {
    doLast {
        def args = []
        def coberturaDir = new File(buildDir, 'cobertura')
        args << '--datafile'
        args << "${coberturaDir.absolutePath}/result.ser"
        args << '--basedir'
        args << projectDir.absolutePath
        new File(projectDir, 'subprojects').eachFileRecurse {
            if (it.name.matches('.*.ser')) {
                args << "${it.absolutePath - projectDir.absolutePath}"
            }
        }
        net.sourceforge.cobertura.merge.Main.main(args as String[])
        args = []
        args << '--datafile'
        args << "${coberturaDir.absolutePath}/result.ser"
        args << 'format'
        args << 'html'
        args << '--destination'
        args << new File(buildDir, 'reports/cobertura')
        subprojects.each { subproj ->
            args.addAll(subproj.sourceSets.main.java.srcDirs)
            // must filter as not every project has the groovy plugin applied
            if (subproj.plugins.hasPlugin('groovy')) {
                args.addAll(subproj.sourceSets.main.groovy.srcDirs)
            }
        }
        net.sourceforge.cobertura.reporting.Main.main(args as String[]);
    }
}
